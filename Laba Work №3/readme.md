# Диаграмма компонентов
1. RestAPI Application - главный компонент, который предоставляет API для взаимодействия с другими модулями и внешними системами.

2. Load Module - компонент, отвечающий за загрузку медицинских данных пациентов для последующего анализа.

3. Analysis Module - компонент, выполняющий анализ медицинских данных с использованием нейросети для диагностирования легочных заболеваний.

4. Visualization Module - компонент, отвечающий за визуализацию результатов анализа и предоставление информации в удобном виде для пользователя.
![paps3-1 drawio](https://github.com/DenisShelby/paps_hse/assets/100212027/a1e5fa0b-50dc-46c7-821a-8bae364d1b68)
# Диаграмма последовательностей
-  Диаграмма последовательностей выглядет следующим образом: 
1) Пользователь отправляет запрос на загрузку медицинских данных через web-сайт.
2) Запрос передается на RestAPI application, где Load module получает и обрабатывает данные.
3) После загрузки данных, analysis module запускает нейросеть для анализа медицинских данных.
4) Результаты анализа передаются в visualization module, который отображает их на web-сайте для пользователя.
![paps3-2 drawio](https://github.com/DenisShelby/paps_hse/assets/100212027/03e5f7fa-0229-4327-877f-89ffe5ae3848)
# Модель БД
- Сущности:
1) Пациент - содержит информацию о пациенте, такую как имя, возраст, пол и историю медицинских записей.
2) Медицинские данные - хранит результаты медицинских тестов, обследований и анализов пациента.
3) Результаты анализа - содержит информацию о результатах анализа медицинских данных с использованием нейросети.
4) Пользователь - хранит информацию о пользователях системы, такую как логин, пароль и роль (например, врач или администратор).
5) Сессия - отслеживает активные сеансы работы пользователей в системе.
![paps3-3 drawio](https://github.com/DenisShelby/paps_hse/assets/100212027/5ff6ae6e-588b-4978-becd-c99a5fa2e7cc)
# Применение основных принципов разработки
- # KISS
Клиентский код:
 ```c#
   // Простой и понятный код для отправки запроса на сервер и получения результатов анализа
function analyzeLungDisease(data) {
  // отправка данных на сервер для анализа
  const result = server.analyzeData(data);
  // отображение результатов анализа на веб-странице
  displayResults(result);
}
  ```
Серверный код:
 ```c#
   // Минимальное количество страниц и простая навигация
app.get('/analyze', (req, res) => {
  res.render('analyze');
});

// Обработка запроса на анализ данных
app.post('/analyze', (req, res) => {
  const data = req.body;
  // анализ данных с использованием нейросети
  const result = neuralNetwork.analyze(data);
  res.send(result);
});
}
  ```
- Принцип KISS был учтен при разработке клиентского и серверного кода путем создания минимального количества страниц и простой навигации на веб-сайте. Клиентский код представляет собой простую функцию для отправки данных на сервер и отображения результатов, в то время как серверный код обрабатывает запросы на анализ данных и возвращает результаты. Это делает использование приложения легким и понятным для пользователя, соответствуя принципу KISS.
- # YAGNI
Клиентский код:
```c#
// Функция отправки запроса на сервер
function sendRequest(url, data) {
  return fetch(url, {
    method: 'POST',
    body: JSON.stringify(data),
    headers: {
      'Content-Type': 'application/json'
    }
  }).then(response => response.json())
}

// Обработчик события отправки формы
document.querySelector('form').addEventListener('submit', event => {
  event.preventDefault()
  
  // Собираем данные из формы
  const data = {
    age: document.querySelector('#age').value,
    gender: document.querySelector('#gender').value,
    smoking: document.querySelector('#smoking').checked,
    cough: document.querySelector('#cough').checked,
    fever: document.querySelector('#fever').checked,
    shortnessOfBreath: document.querySelector('#shortness-of-breath').checked
  }
  
  // Отправляем запрос на сервер
  sendRequest('/diagnose', data)
    .then(result => {
      // Выводим результат на страницу
      document.querySelector('#result').textContent = result.message
    })
})
```
Серверный код:
```c#
const express = require('express')
const bodyParser = require('body-parser')

const app = express()

// Парсер для тела запроса в формате JSON
app.use(bodyParser.json())

// Обработчик POST-запроса на /diagnose
app.post('/diagnose', (req, res) => {
  const { age, gender, smoking, cough, fever, shortnessOfBreath } = req.body
  
  // Обучение нейросети и диагностика заболевания
  
  const result = { message: 'Вы здоровы' }
  
  res.json(result)
})

// Запуск сервера на порту 3000
app.listen(3000, () => {
  console.log('Сервер запущен на порту 3000')
})
```
Принцип YAGNI (You Ain't Gonna Need It) означает, что необходимо писать только тот код, который действительно нужен для решения текущей задачи. В данном проекте этот принцип был учтен следующим образом:
1) Клиентский код содержит только необходимый минимум для отправки данных на сервер и отображения результата на странице. Например, здесь нет лишних функций для валидации данных или обработки ошибок.
2) Серверный код содержит только обработчик POST-запроса на /diagnose и минимальный набор операций для диагностики заболевания. Например, здесь нет лишних функций для сохранения данных в базе или обработки других типов запросов.
- # DRY 
Клиентский код:
```c#
// Функция для отправки запроса на сервер
function sendDataToServer(data, endpoint) {
  // отправка данных на сервер
  return fetch(endpoint, {
    method: 'POST',
    body: JSON.stringify(data),
    headers: {
      'Content-Type': 'application/json'
    }
  })
  .then(response => response.json())
  .catch(error => console.error('Error:', error));
}

// Функция для отображения результатов анализа
function displayResults(result) {
  // отображение результатов на веб-странице
}
```
Серверный код:
```c#
// Обработка запроса на анализ данных
app.post('/analyze', (req, res) => {
  const data = req.body;
  // анализ данных с использованием нейросети
  const result = neuralNetwork.analyze(data);
  res.send(result);
});
```
- В данном случае, созданы отдельные функции для отправки данных на сервер и отображения результатов, которые могут быть повторно использованы в других частях приложения. Таким образом, избегаем повторения одного и того же кода в разных частях приложения, соответствуя принципу DRY.
- # SOLID 
Клиентский код:
```c#
// Интерфейс для отправки данных на сервер
class DataSender {
  sendDataToServer(data, endpoint) {
    return fetch(endpoint, {
      method: 'POST',
      body: JSON.stringify(data),
      headers: {
        'Content-Type': 'application/json'
      }
    })
    .then(response => response.json())
    .catch(error => console.error('Error:', error));
  }
}

// Интерфейс для отображения результатов анализа
class ResultDisplayer {
  displayResults(result) {
    // отображение результатов на веб-странице
  }
}
```
Серверный код:
```c#
// Обработчик запроса на анализ данных
app.post('/analyze', (req, res) => {
  const data = req.body;
  // анализ данных с использованием нейросети
  const result = neuralNetwork.analyze(data);
  res.send(result);
});
```
В данном случае, испольщуется интерфейсы для отправки данных на сервер и отображения результатов анализа. Это позволяет соблюдать принцип SOLID, а именно принцип единственной ответственности (Single Responsibility Principle), так как каждый класс отвечает только за одну функцию - отправку данных или отображение результатов. Таким образом, избегается смешивания различных функциональностей в одном классе и делаем код более гибким и легким для поддержки и изменений.
# Дополнительные принципы разработки
1) BDUF. Применимость: Отказ. При проектировании web-приложения для диагностирования легочных заболеваний, необходимо учитывать, что требования и технические решения могут меняться в процессе разработки. Поэтому масштабное проектирование прежде всего может привести к излишней сложности и избыточности, а также затруднить внесение изменений в процессе разработки.

2) SoC. Применимость: Применим. Принцип разделения ответственности позволяет разделять функциональность системы на отдельные компоненты, что упрощает поддержку и расширение кода. Например, разделение интерфейса для отправки данных на сервер и отображения результатов анализа позволяет изменять эти части независимо друг от друга.

3) MVP. Применимость: Применим. Разработка минимально жизнеспособного продукта позволяет быстрее вывести продукт на рынок, получить обратную связь от пользователей и внести необходимые изменения. Это особенно важно при создании web-приложения, где быстрый запуск и обновление функциональности являются ключевыми.

4) PoC. Применимость: Применим. Доказательство концепции позволяет проверить работоспособность и целесообразность выбранных технических решений, например, обучение нейросети для диагностирования легочных заболеваний. Это поможет избежать потенциальных проблем и ошибок на более поздних этапах разработки.
