# Диаграмма компонентов
1. RestAPI Application - главный компонент, который предоставляет API для взаимодействия с другими модулями и внешними системами.

2. Load Module - компонент, отвечающий за загрузку медицинских данных пациентов для последующего анализа.

3. Analysis Module - компонент, выполняющий анализ медицинских данных с использованием нейросети для диагностирования легочных заболеваний.

4. Visualization Module - компонент, отвечающий за визуализацию результатов анализа и предоставление информации в удобном виде для пользователя.
![paps3-1 drawio](https://github.com/DenisShelby/paps_hse/assets/100212027/a1e5fa0b-50dc-46c7-821a-8bae364d1b68)
# Диаграмма последовательностей
-  Диаграмма последовательностей выглядет следующим образом: 
1) Пользователь отправляет запрос на загрузку медицинских данных через web-сайт.
2) Запрос передается на RestAPI application, где Load module получает и обрабатывает данные.
3) После загрузки данных, analysis module запускает нейросеть для анализа медицинских данных.
4) Результаты анализа передаются в visualization module, который отображает их на web-сайте для пользователя.
![paps3-2 drawio](https://github.com/DenisShelby/paps_hse/assets/100212027/03e5f7fa-0229-4327-877f-89ffe5ae3848)
# Модель БД
- Сущности:
1) Пациент - содержит информацию о пациенте, такую как имя, возраст, пол и историю медицинских записей.
2) Медицинские данные - хранит результаты медицинских тестов, обследований и анализов пациента.
3) Результаты анализа - содержит информацию о результатах анализа медицинских данных с использованием нейросети.
4) Пользователь - хранит информацию о пользователях системы, такую как логин, пароль и роль (например, врач или администратор).
5) Сессия - отслеживает активные сеансы работы пользователей в системе.
![paps3-3 drawio](https://github.com/DenisShelby/paps_hse/assets/100212027/e22bbb1b-c90f-41f4-a3ec-e5e0b58d6f7d)
# Применение основных принципов разработки
Клиентский код:

```javascript
class DiagnosticsApp:
    def __init__(self):
        self.server_url = "http://example.com/api/diagnostics"
    
    def run(self):
        patient_info = self.get_patient_info()
        symptoms = self.get_symptoms()
        diagnosis = self.send_diagnosis_request(patient_info, symptoms)
        self.display_diagnosis(diagnosis)
    
    def get_patient_info(self):
        # Здесь получаем информацию о пациенте от пользователя
        pass
    
    def get_symptoms(self):
        # Здесь получаем симптомы от пользователя
        pass
    
    def send_diagnosis_request(self, patient_info, symptoms):
        # Отправляем запрос на сервер с информацией о пациенте и симптомами
        pass
    
    def display_diagnosis(self, diagnosis):
        # Отображаем диагноз пациенту
        pass

app = DiagnosticsApp()
app.run()
```

В клиентском коде были учтены следующие принципы:

1. KISS (Keep It Simple, Stupid) - код прост и понятен. Он не содержит избыточных деталей и лишних сложностей, что упрощает его понимание и поддержку.

2. YAGNI (You Ain't Gonna Need It) - код реализует только необходимый функционал для работы с приложением. Не добавлены ненужные фичи, которые могут привести к излишней сложности и перегрузке системы.

3. DRY (Don't Repeat Yourself) - код структурирован таким образом, чтобы избежать дублирования кода. Методы get_patient_info, get_symptoms, send_diagnosis_request и display_diagnosis выделены в отдельные функции для повторного использования и улучшения поддерживаемости кода.

4. SOLID - класс DiagnosticsApp следует принципу единственной ответственности, так как он отвечает только за запуск приложения и координацию работы других компонентов. Каждый метод класса выполняет только одну задачу. Также класс легко расширяем и поддерживаем, так как методы могут быть заменены или переопределены при необходимости.

Серверный код:

```python
from flask import Flask, request

app = Flask(__name__)

@app.route("/api/diagnostics", methods=["POST"])
def diagnose():
    patient_info = request.json["patient_info"]
    symptoms = request.json["symptoms"]
    diagnosis = process_diagnosis(patient_info, symptoms)
    return {"diagnosis": diagnosis}

def process_diagnosis(patient_info, symptoms):
    # Здесь обрабатываем информацию о пациенте и симптомы
    pass

if __name__ == "__main__":
    app.run()
```

В серверном коде были учтены следующие принципы:

1. KISS (Keep It Simple, Stupid) - код сервера написан с использованием фреймворка Flask, который предоставляет простой и понятный способ создания веб-приложений. Код сервера минимален и выполняет только одну функцию - обработку запросов и отправку диагноза.

2. YAGNI (You Ain't Gonna Need It) - серверный код реализует только необходимый функционал для обработки запроса на диагностику. Не добавлены ненужные фичи, которые могут привести к излишней сложности и перегрузке системы.

3. DRY (Don't Repeat Yourself) - функция process_diagnosis выделена для обработки информации о пациенте и симптомах. Она может быть повторно использована в других частях кода, что улучшает поддерживаемость и избегает дублирования кода.

4. SOLID - код сервера построен на принципе единственной ответственности. Функция diagnose отвечает только за обработку запроса и возврат диагноза. Код легко расширяем и поддерживаем, так как функции могут быть заменены или переопределены при необходимости.
# Дополнительные принципы разработки
1) BDUF. Применимость: Отказ. При проектировании web-приложения для диагностирования легочных заболеваний, необходимо учитывать, что требования и технические решения могут меняться в процессе разработки. Поэтому масштабное проектирование прежде всего может привести к излишней сложности и избыточности, а также затруднить внесение изменений в процессе разработки.

2) SoC. Применимость: Применим. Принцип разделения ответственности позволяет разделять функциональность системы на отдельные компоненты, что упрощает поддержку и расширение кода. Например, разделение интерфейса для отправки данных на сервер и отображения результатов анализа позволяет изменять эти части независимо друг от друга.

3) MVP. Применимость: Применим. Разработка минимально жизнеспособного продукта позволяет быстрее вывести продукт на рынок, получить обратную связь от пользователей и внести необходимые изменения. Это особенно важно при создании web-приложения, где быстрый запуск и обновление функциональности являются ключевыми.

4) PoC. Применимость: Применим. Доказательство концепции позволяет проверить работоспособность и целесообразность выбранных технических решений, например, обучение нейросети для диагностирования легочных заболеваний. Это поможет избежать потенциальных проблем и ошибок на более поздних этапах разработки.
